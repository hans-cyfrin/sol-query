[
  {
    "id": 13,
    "title": "LiquidityPool contract suffers permanent fund loss due to failed reward transfers",
    "body": "**Description:** \nThe `LiquidityPool::claimReward` function contains a critical flaw that causes permanent financial loss to the protocol when user reward transfers fail. The function transfers the protocol fee (10% of the reward amount) to the owner before attempting to transfer the remaining amount to the user. If the user transfer fails due to reasons such as the recipient being a contract that reverts on receive, the protocol fee has already been deducted from the contract's balance and transferred to the owner. However, the user's `rewards` mapping and `nonce` are only updated upon successful user transfer. This means the protocol permanently loses the fee amount while the user retains their full reward claim, allowing them to attempt the claim again. Malicious users can exploit this by intentionally causing transfer failures through contracts that revert on receive, repeatedly draining protocol fees while maintaining their reward balances.\n\n**Impact:** \nThe protocol suffers permanent financial loss through drained fees, while users can repeatedly exploit failed transfers to claim rewards multiple times without their balances being decremented.\n\n**Proof Of Concept:** \n\n```solidity\nfunction testProtocolLossOnFailedRewardClaim() public {\n    uint256 depositAmount = 1 ether;\n    uint256 rewardAmount = 0.1 ether;\n    uint256 protocolFee = rewardAmount / 10; // 0.01 ether\n    \n    // Setup: user deposits and earns rewards\n    uint256 privateKey = 0x1234;\n    address user = vm.addr(privateKey);\n    vm.deal(user, 10 ether);\n    \n    vm.prank(user);\n    pool.deposit{value: depositAmount}();\n    \n    // Fund pool for rewards\n    vm.deal(address(pool), address(pool).balance + 1 ether);\n    uint256 poolBalanceBefore = address(pool).balance;\n    uint256 ownerBalanceBefore = address(this).balance;\n    \n    // Deploy malicious contract that reverts on receive\n    MaliciousRewardClaimer malicious = new MaliciousRewardClaimer();\n    \n    // Prepare signature for reward claim\n    uint256 nonce = pool.nonces(user);\n    bytes32 messageHash = keccak256(abi.encode(user, rewardAmount, nonce));\n    (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, messageHash);\n    bytes memory signature = abi.encodePacked(r, s, v);\n    \n    // Malicious contract claims reward - fee transferred but user transfer fails\n    vm.prank(address(malicious));\n    pool.claimReward(user, rewardAmount, nonce, signature);\n    \n    // Protocol lost the fee permanently\n    assertEq(address(pool).balance, poolBalanceBefore - protocolFee);\n    assertEq(address(this).balance, ownerBalanceBefore + protocolFee);\n    \n    // User's rewards and nonce unchanged - can claim again\n    assertEq(pool.rewards(user), (depositAmount * pool.REWARD_RATE()) / 100);\n    assertEq(pool.nonces(user), nonce);\n    \n    // User can attempt to claim again, causing more fee loss\n    vm.prank(address(malicious));\n    pool.claimReward(user, rewardAmount, nonce, signature);\n    \n    // Another fee lost\n    assertEq(address(pool).balance, poolBalanceBefore - (protocolFee * 2));\n    assertEq(address(this).balance, ownerBalanceBefore + (protocolFee * 2));\n}\n\ncontract MaliciousRewardClaimer {\n    receive() external payable {\n        revert(\"Intentional failure to exploit fee loss\");\n    }\n}\n```\n\n**Recommended Mitigation:** \n\nEnsure both transfers succeed before updating state, or revert the entire transaction if either transfer fails:\n\n```diff\nfunction claimReward(\n    address user,\n    uint256 amount,\n    uint256 nonce,\n    bytes memory signature\n) external {\n    require(rewards[user] >= amount, \"Insufficient rewards\");\n    require(nonces[user] == nonce, \"Invalid nonce\");\n\n    // Verify cryptographic signature to prevent unauthorized claims\n    bytes32 messageHash = keccak256(abi.encode(user, amount, nonce));\n    address signer = ECDSA.recover(messageHash, signature);\n    require(signer == user, \"Invalid signature\");\n\n    // Calculate protocol fee and user amount\n    uint256 fee = amount / 10; // 10% protocol fee\n    uint256 userAmount = amount - fee;\n\n-   // Transfer protocol fee to treasury\n-   (bool feeSuccess,) = owner().call{value: fee}(\"\");\n-   require(feeSuccess, \"Fee transfer failed\");\n-\n-   // Transfer remaining amount to user\n-   (bool success,) = msg.sender.call{value: userAmount}(\"\");\n-   if (success) {\n-       rewards[user] -= amount;\n-       nonces[user]++;\n-\n-       // Emit event for tracking reward claims\n-       emit RewardClaimed(user, userAmount);\n-   }\n\n+   // Transfer remaining amount to user first\n+   (bool success,) = msg.sender.call{value: userAmount}(\"\");\n+   require(success, \"User transfer failed\");\n+   \n+   // Transfer protocol fee to treasury\n+   (bool feeSuccess,) = owner().call{value: fee}(\"\");\n+   require(feeSuccess, \"Fee transfer failed\");\n+   \n+   // Update state only after both transfers succeed\n+   rewards[user] -= amount;\n+   nonces[user]++;\n+   \n+   // Emit event for tracking reward claims\n+   emit RewardClaimed(user, userAmount);\n}\n```",
    "severity": "high"
  },
  {
    "id": 12,
    "title": "Incorrect share calculation for deposits after first deposit",
    "body": "**Description:** \nThe `LiquidityPool::_processDeposit` function calculates shares for subsequent deposits using `address(this).balance` which already includes the current deposit amount. When users call `deposit()` or `depositFor()`, the ETH is transferred to the contract before `_processDeposit` is executed, meaning `address(this).balance` includes both the previous pool balance and the new deposit. The share calculation formula `shares = (amount * shareToken.totalSupply()) / address(this).balance` therefore uses an inflated denominator, causing users to receive significantly fewer shares than they deserve. This creates an unfair advantage for early depositors who receive shares at better rates, while later depositors systematically lose value.\n\n**Impact:**\nUsers depositing after the first deposit receive substantially fewer shares than they should, resulting in direct financial loss when they later withdraw their funds.\n\n**Proof Of Concept:** \n1. First user deposits 100 ETH → receives 100 shares (1:1 ratio)\n2. Second user deposits 100 ETH → receives only 50 shares instead of 100\n   - Calculation: `(100 * 100) / 200 = 50` shares (using inflated balance)\n   - Should be: `(100 * 100) / 100 = 100` shares (using pre-deposit balance)\n3. When second user withdraws: `50 * 200 / 150 = 66.67` ETH returned\n4. Result: User deposited 100 ETH but can only withdraw 66.67 ETH (33.33 ETH loss)\n\n**Recommended Mitigation:** \nUse the pool balance before the current deposit in the share calculation:\n\n```diff\nfunction _processDeposit(address user, uint256 amount) internal {\n    uint256 shares;\n    if (shareToken.totalSupply() == 0) {\n        shares = amount;\n    } else {\n-       shares = (amount * shareToken.totalSupply()) / address(this).balance;\n+       shares = (amount * shareToken.totalSupply()) / (address(this).balance - amount);\n    }\n    \n    shareToken.mint(user, shares);\n    // ... rest of function\n}\n```",
    "severity": "critical"
  },
  {
    "id": 9,
    "title": "Cross-chain signature replay vulnerability allows unauthorized reward claims on different networks",
    "body": "**Description:** \nThe `LiquidityPool::claimReward` function generates the message hash for signature verification using only `user`, `amount`, and `nonce` parameters at line 129: `keccak256(abi.encode(user, amount, nonce))`. This signature scheme lacks any chain-specific identifiers such as `block.chainid` or the contract address, making it vulnerable to cross-chain replay attacks. If the same contract is deployed on multiple blockchains (such as Ethereum mainnet, Polygon, Arbitrum, etc.), an attacker can take a valid signature from one chain and replay it on another chain to claim rewards they are not entitled to. Since nonces are maintained separately on each chain and users may have different reward balances across chains, an attacker could potentially claim rewards multiple times using the same signature on different networks, effectively stealing funds from the protocol on chains where they have no legitimate rewards.\n\n**Impact:** \nValid signatures from one blockchain can be replayed on other chains to steal rewards, allowing attackers to claim funds they are not entitled to across multiple networks where the contract is deployed.\n**Recommended Mitigation:** \n\nInclude chain-specific identifiers in the message hash to prevent cross-chain replay attacks:\n\n```diff\n    function claimReward(\n        address user,\n        uint256 amount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        require(rewards[user] >= amount, \"Insufficient rewards\");\n        require(nonces[user] == nonce, \"Invalid nonce\");\n\n        // Verify cryptographic signature to prevent unauthorized claims\n-       bytes32 messageHash = keccak256(abi.encode(user, amount, nonce));\n+       bytes32 messageHash = keccak256(abi.encode(\n+           user, \n+           amount, \n+           nonce, \n+           block.chainid, \n+           address(this)\n+       ));\n        address signer = ECDSA.recover(messageHash, signature);\n        require(signer == user, \"Invalid signature\");\n\n        uint256 fee = amount / 10;\n        uint256 userAmount = amount - fee;\n\n        (bool feeSuccess,) = owner().call{value: fee}(\"\");\n        require(feeSuccess, \"Fee transfer failed\");\n\n        (bool success,) = msg.sender.call{value: userAmount}(\"\");\n        if (success) {\n            rewards[user] -= amount;\n            nonces[user]++;\n            emit RewardClaimed(user, userAmount);\n        }\n    }\n```",
    "severity": "low"
  },
  {
    "id": 8,
    "title": "Signature verification mismatch allows theft of user rewards through claimReward function",
    "body": "**Description:** \n\nThe `LiquidityPool::claimReward` function contains a critical flaw in its signature verification logic that allows attackers to steal rewards from legitimate users. While the function correctly verifies that the signature was created by the `user` parameter at line 131 using `require(signer == user, \"Invalid signature\")`, it transfers the reward amount to `msg.sender` instead of the verified `user` at line 140. This mismatch means that if an attacker can obtain a valid signature from any user (through social engineering, phishing, or by compromising the user's signing process), they can call `claimReward` with the victim's signature parameters but receive the rewards themselves. The signature verification only confirms that the `user` authorized the specific `amount` and `nonce`, but does not enforce that the same `user` must be the one calling the function to receive the rewards.\n\n**Impact:** \nAn attacker who obtains any user's valid signature can steal that user's accumulated rewards by calling claimReward and receiving the funds themselves instead of the legitimate user.\n\n**Proof Of Concept:** \n\n```solidity\n// Victim creates a valid signature for claiming 100 ETH rewards\naddress victim = 0x123...;\nuint256 amount = 100 ether;\nuint256 nonce = nonces[victim]; // Current nonce: 0\nbytes32 messageHash = keccak256(abi.encode(victim, amount, nonce));\n// Victim signs messageHash, producing validSignature\n\n// Attacker obtains this signature (through phishing, social engineering, etc.)\n// Attacker calls claimReward with victim's parameters\ncontract Attacker {\n    function stealRewards(\n        LiquidityPool pool,\n        address victim,\n        uint256 amount,\n        uint256 nonce,\n        bytes memory validSignature\n    ) external {\n        // This call will succeed because:\n        // 1. Signature verification passes (signed by victim)\n        // 2. But reward is sent to msg.sender (attacker)\n        pool.claimReward(victim, amount, nonce, validSignature);\n        \n        // Attacker receives victim's rewards\n        // Victim's reward balance is reduced but they get nothing\n    }\n}\n```\n\n**Recommended Mitigation:** \n\nEnsure that rewards are transferred to the verified signer rather than the caller, or require that `msg.sender` equals the `user` parameter:\n\n```diff\n    function claimReward(\n        address user,\n        uint256 amount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        require(rewards[user] >= amount, \"Insufficient rewards\");\n        require(nonces[user] == nonce, \"Invalid nonce\");\n\n        bytes32 messageHash = keccak256(abi.encode(user, amount, nonce));\n        address signer = ECDSA.recover(messageHash, signature);\n        require(signer == user, \"Invalid signature\");\n+       require(msg.sender == user, \"Caller must be the reward owner\");\n\n        uint256 fee = amount / 10;\n        uint256 userAmount = amount - fee;\n\n        (bool feeSuccess,) = owner().call{value: fee}(\"\");\n        require(feeSuccess, \"Fee transfer failed\");\n\n-       (bool success,) = msg.sender.call{value: userAmount}(\"\");\n+       (bool success,) = user.call{value: userAmount}(\"\");\n        if (success) {\n            rewards[user] -= amount;\n            nonces[user]++;\n            emit RewardClaimed(user, userAmount);\n        }\n    }\n```",
    "severity": "critical"
  },
  {
    "id": 7,
    "title": "Griefing attack via depositFor function can permanently prevent user withdrawals",
    "body": "**Description:** \nThe `LiquidityPool::depositFor` function allows any external caller to deposit ETH on behalf of any user without permission or access controls. This function calls `_processDeposit`, which updates `lastDepositTime[user] = block.timestamp` at line 176, resetting the withdrawal delay period for the target user. Since the `withdraw` function enforces a 24-hour delay by requiring `block.timestamp >= lastDepositTime[msg.sender] + WITHDRAWAL_DELAY` at line 93, an attacker can exploit this by repeatedly calling `depositFor` with minimal amounts (as low as 1 wei) for any victim user. Each malicious deposit resets the victim's `lastDepositTime` to the current timestamp, effectively preventing them from ever satisfying the withdrawal delay requirement. This creates a permanent denial-of-service attack where legitimate users become unable to withdraw their funds, despite having valid pool shares, simply because an attacker continuously deposits tiny amounts on their behalf.\n\n**Impact:** \nAn attacker can permanently lock any user's funds in the protocol by repeatedly making minimal deposits on their behalf, preventing legitimate withdrawals indefinitely at very low cost.\n\n**Recommended Mitigation:** \nRemove the `depositFor` function or implement authorization to prevent unauthorized deposits on behalf of other users:\n\n```diff\n-   function depositFor(address user) external payable {\n-       require(msg.value > 0, \"Invalid deposit\");\n-       _processDeposit(user, msg.value);\n-   }\n```\n\nAlternatively, if `depositFor` functionality is required, implement proper authorization:\n\n```diff\n+   mapping(address => mapping(address => bool)) public depositAuthorizations;\n+   \n+   function authorizeDepositor(address depositor, bool authorized) external {\n+       depositAuthorizations[msg.sender][depositor] = authorized;\n+   }\n\n    function depositFor(address user) external payable {\n        require(msg.value > 0, \"Invalid deposit\");\n+       require(\n+           depositAuthorizations[user][msg.sender] || user == msg.sender,\n+           \"Not authorized to deposit for this user\"\n+       );\n        _processDeposit(user, msg.value);\n    }\n```",
    "severity": "medium"
  },
  {
    "id": 6,
    "title": "Malicious or incompatible owner contract can permanently block all reward claims",
    "body": "**Description:** \nThe `LiquidityPool::claimReward` function transfers a 10% protocol fee to the owner using a low-level `call` at line 138, followed by a `require` statement that reverts the entire transaction if the transfer fails. If the owner is set to a contract address that does not implement a `payable` `receive()` or `fallback()` function, or if the owner contract is designed to always revert on ETH transfers, the fee transfer will fail and cause the entire `claimReward` transaction to revert. This creates a critical denial-of-service vulnerability where a malicious or incompatible owner can permanently block all users from claiming their accumulated rewards, even though the user's portion of the transfer might succeed. The issue is compounded by the fact that ownership transfer is typically possible in `Ownable` contracts, allowing an attacker who gains control to intentionally brick the reward claiming functionality.\n\n**Impact:** \nA malicious owner or owner contract without ETH receiving capability can permanently prevent all users from claiming their rewards, effectively freezing user funds in the protocol.\n\n**Recommended Mitigation:** \n\nImplement a pull-based fee collection mechanism instead of pushing fees during reward claims, allowing the owner to withdraw accumulated fees separately:\n\n```diff\n+   uint256 public accumulatedFees;\n\n    function claimReward(\n        address user,\n        uint256 amount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        require(rewards[user] >= amount, \"Insufficient rewards\");\n        require(nonces[user] == nonce, \"Invalid nonce\");\n\n        bytes32 messageHash = keccak256(abi.encode(user, amount, nonce));\n        address signer = ECDSA.recover(messageHash, signature);\n        require(signer == user, \"Invalid signature\");\n\n        uint256 fee = amount / 10;\n        uint256 userAmount = amount - fee;\n\n-       // Transfer protocol fee to treasury\n-       (bool feeSuccess,) = owner().call{value: fee}(\"\");\n-       require(feeSuccess, \"Fee transfer failed\");\n+       // Accumulate fees for owner to withdraw later\n+       accumulatedFees += fee;\n\n        // Transfer remaining amount to user\n        (bool success,) = msg.sender.call{value: userAmount}(\"\");\n-       if (success) {\n+       require(success, \"Transfer failed\");\n            rewards[user] -= amount;\n            nonces[user]++;\n            emit RewardClaimed(user, userAmount);\n-       }\n    }\n\n+   function withdrawFees() external onlyOwner {\n+       uint256 amount = accumulatedFees;\n+       accumulatedFees = 0;\n+       (bool success,) = owner().call{value: amount}(\"\");\n+       require(success, \"Fee withdrawal failed\");\n+   }\n```",
    "severity": "low"
  },
  {
    "id": 3,
    "title": "Unrestricted minting allows anyone to mint unlimited stablecoins",
    "body": "**Description:** \nThe `StableCoin::mint` function lacks any access control mechanisms, allowing any external caller to mint unlimited amounts of tokens to any address. In a stablecoin protocol, token minting should be strictly controlled and typically reserved for authorized entities such as the protocol owner, governance contracts, or specific minting contracts that ensure proper collateralization. The current implementation at lines 37-41 simply calls the internal `_mint` function without any authentication or authorization checks, effectively breaking the fundamental economic model of a stablecoin where token supply should be backed by collateral or controlled through governance mechanisms.\n\n**Impact:** \nAny malicious actor can mint unlimited `USDS` tokens, completely destroying the token's value and stability by inflating the supply without any backing collateral.\n\n**Proof Of Concept:** \n```solidity\n// Any address can call this function\nStableCoin stablecoin = StableCoin(stablecoinAddress);\n\n// Attacker mints 1 billion tokens to themselves\nstablecoin.mint(attackerAddress, 1_000_000_000 * 10**1); // 1 billion tokens\n\n// Or attacker can mint to any address, including protocol contracts\nstablecoin.mint(liquidityPoolAddress, 1_000_000_000 * 10**1);\n```\n\n**Recommended Mitigation:** \nImplement proper access control to restrict minting functionality to authorized addresses only. The most secure approach is to add an `onlyOwner` modifier or similar access control mechanism:\n\n```diff\n+ import \"@openzeppelin/contracts/access/Ownable.sol\";\n\n- contract StableCoin is ERC20 {\n+ contract StableCoin is ERC20, Ownable {\n\n    constructor() ERC20(\"USD Stable\", \"USDS\") {\n        _mint(msg.sender, 1000000 * 10 ** decimals());\n    }\n\n-   function mint(address to, uint256 amount) external {\n+   function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n        emit TokensMinted(to, amount);\n    }\n```\n",
    "severity": "critical"
  },
  {
    "id": 2,
    "title": "Blacklisted group member prevents all members from withdrawing staked tokens",
    "body": "**Description:** \nIn the `GroupStaking::withdrawFromGroup` function, tokens are distributed to all group members simultaneously through a loop that calls `token.transfer(group.members[i], memberShare)` for each member. Since the `GovernanceToken` contract implements blacklist functionality that reverts transfers to blacklisted addresses with \"Recipient is blacklisted\", if any single group member becomes blacklisted, the entire withdrawal transaction will revert. This creates a denial of service condition where all group members lose access to their proportional share of staked tokens, even if they themselves are not blacklisted. The issue stems from the atomic nature of the distribution loop - a single failed transfer causes the entire operation to fail, preventing legitimate users from accessing their funds.\n\n**Impact:** \nBlacklisting of a single group member permanently locks all staked tokens for the entire group, preventing non-blacklisted members from withdrawing their proportional shares.\n\n**Recommended Mitigation:** \nModify the `withdrawFromGroup` function to handle blacklisted recipients gracefully by checking the blacklist status before attempting transfers and adding skipped amounts back to the group balance:\n\n```diff\n// Distribute tokens according to weights\nfor (uint256 i = 0; i < group.members.length; i++) {\n    uint256 memberShare = (_amount * group.weights[i]) / 100;\n    if (memberShare > 0) {\n-       token.transfer(group.members[i], memberShare);\n+       if (!token.blacklisted(group.members[i])) {\n+           token.transfer(group.members[i], memberShare);\n+       } else {\n+           // Add blacklisted member's share back to group balance\n+           group.totalAmount += memberShare;\n+       }\n    }\n}\n```",
    "severity": "medium"
  }
]